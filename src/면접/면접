 1번. 자료형
 
 /* 1. 기본 자료형(Primitive Type) : 실제값이 저장
 *    정수형 : byte(1바이트) -> short(2바이트) -> int(4바이트) -> long(8바이트)
 *    실수형 : float(4바이트) -> double(8바이트)
 *    문자형 : char(2바이트)
 *    부울형 : boolean(true/false)
 *       
 * 2. 참조형(Reference Type) : 실제 객체를 가리키는 주소값 저장
 *     클래스, 인터페이스, 배열      
 * 
 * 3. 문자열 : String 클래스 
 */
 
 ===================================
 2번. 상수
    /*
    * 상수 : 프로그램이 실행되는 동안, 값이 변하지 않는 수 또는 변경불가능한 수
    *      final 키워드는 변수에 값이 대입되고 나면, 변수값이 더이상 변경되지 않는다는 의미
    *      주로 대문자를 사용
    *      만일 값변경시 상수를 선언한 부분의 값만 변경한다. 
    * final  p305
     * 1) 변수(상수) : 변수에 값 대입불가
     * 2) 메서드 : 재정의 불가
     * 3) 클래스 : 상속 불가
    */
   final double PI = 3.14;  // 상수선언 및 초기화  .. 면접
===================================

 3번. 구구단 예제
   for / while

 4번. 객체 설명
    
    /*        
    *  인스턴스 생성 : 클래스명 참조변수명 = new 클래스명();    // new 생성자;
    *        접근 : 참조변수명.멤버변수
    *             참조변수명.멤버메서드;
    *  - 참조변수명에는 생성한 인스턴스의 힙메모리공간 주소값이 들어있다. 스택메모리에 생성
    *    앞의 클래스명은 데이터타입이고, 참조변수로 접근할 때 사용한다.
    *    뒤의 클래스명은 힙메모리에 인스턴스 생성시 사용되는 생성자이다.   
 
     * 클래스 : 객체에 대한 설계도, 디자인
    *       -멤버변수(속성, 필드) + 멤버메서드(기능, 동작) + 생성자
    *       
    * 클래스는 설계도(디자인)이며, 인스턴스는 이 설계도를 바탕으로 만들어진 힙메모리 공간이다.
    *        그 결과 주소값이 만들어지며, 참조변수에 할당된다.
    *        객체는 인스턴스라고도 한다.
    */ 
    
 5번. setter / getter    

 6번. 생성자 오버로드 vs 상속 오버라이딩
	생성자 오버로드 : 생성자가 두개 이상 제공되는 경우를 생성자 오버로드라고 한다.
	오버로드 : 메서드나 생성자의 매개변수 갯수가 다르거나, 매개변수 타입이 다른경우 말한다.( 단 리턴타입은 무관한다.)
	
	상속 오버라이딩(=재정의) : 부모 메서드를 재정의
	
	/*250page [면접] 오버로드 vs 오버라이드 
	 * @Override 어노테이션 : "이 메서드는 재정의된 메서드입니다."라고 컴파일러에게 명확히 알려주는 역할을 한다.
	 * 오버라이딩(=재정의)
	 * - 자식클래스의 메서드가 부모클래스의 메서드를 오버라이드(재정의)한다고 말한다.
	 * -상속에서 부모클래스의 메서드를 변경하고자 할 때 사용한다.
	 * - 메서드 이름, 매개변수, 매개변수 자료형, 반환형까지 모두 동일해야 한다.
	 *	(동일하지 않으면 컴파일러가 다른 메서드로 인식한다.)
	 * -호출시 오버라이딩한 자식 메서드가 호출된다.
	 * 	(오버라이드 목적 : 부모클래스의 메서드를 변경해서 자식쪽에서 호출하고자 하는 의도)
	 * 	사전적인 의미 : 부모 메서드의 기능을 무시한다.
	 */
	
 7번 . static 변수

		/*[면접]
       * static 변수 = 정적변수 = 공유변수 = 클래스변수
       * static 변수 :
       * - 프로그램이 실행되어 메모리에 올라갔을 때 딱 한번 데이터영역 메모리 공간에 할당된다.
       * - 객체를 생성하지 않고, 바로 클래스명으로 접근가능하다.
       *   인스턴스마다 생성되는 변수가 아니라, 클래스에 속해 한번만 생성되는 변수이고, 여러 인스턴스가 공유하기 때문이다.
       *   인스턴스가 생성되지 않아도 사용할 수 있기 때문에 클래스명.멤버변수, 클래스명.멤버메서드 사용가능
       *   
       * - static 변수나 메서드는 static 메서드에서 호출가능
       * (정적메서드에서 인스턴스 변수나 메서드를 호출시 컴파일 오류가 난다.)
       * static 메서드는 프로그램 실행시 자동으로 메모리에 올라가나, 일반메서드는 객체를 생성해야 메모리에 올라간다.
       * 
       */
       
 8번. 싱글톤 패턴
 	/*
	 * [면접] 싱글톤 패턴 193page
	 * - 동일한 인스턴스를 단 하나만 생성하는 디자인 패턴
	 * - static을 응용
	 * - 접근할 클래스에 여러 메서드가 있을 때, 외부 클래스가 해당 해당 메서드에 접근할 때마다 
	 *   인스턴스를 생성할 필요없이 getInstance()를 통해 참조변수만 리턴받아서 접근한다.
	 *   열번,백번을 호출해도  같은 주소의 인스턴스가 반복된다.
	 * 
	 * - 싱글톤 패턴 생성
	 * - 1단계. 생성자를 private으로 만들기.
	 * - 2단계. 클래스 내부에 static으로 유일한 인스턴스를 생성한다.
	 * - 3단계. 외부에서 참조할 수 있는 public 메서드를 만든다.
	 * 
	 * - 호출하는 방법
	 * - 외부클래스명 참조변수 = 외부클래스명.getInstance();
	 * 예) _07_Company company = _07_Company.getINstance();  //클래스명.메서드명
	 */
	 
 9번. 배열
	  * 배열(Array) : 같은 타입의 대량의 데이터를 저장할 수 있는 저장장소이다.
       * 방법1) 선언과 생성을 따로 한다.
       *       int[] scores; // 선언
       *      scores = new int[갯수];   // 생성
       *      scores[index] = 값;
       * 
       * 방법2) 선언과 생성을 동시에 한다... 추천
       *      배열자료형[] 배열명 = new 배열자료형[배열갯수];
       *      배열명[index] = 값;
       *      
       * 방법3)  int[] scores = new int[] {1,2,3,4,5}  // 개수는 생략해야 함   
       *     오류) int[] scores = new int[5]{1,2,3,4,5}; // 갯수가 있으므로 오류발생
       *     int[] 배열명;
       *     배열명 = new 자료형[] {값1, 값2, 값3..값n};  //  new 자료형[] 생략시 오류발생
       * 
       * 방법4) 선언과 할당을 동시에 한다... 제일 많이 사용한다.
       *      배열자료형[] 배열명 = {값1, 값2, 값3..값n};
       *
       * - 객체형 배열 사용 (참조자료형으로 선언하는 객체배열)
       * - 클래스명[] 참조변수 = new 클래스명[배열갯수];
       * - 인스턴스를 그 인스턴스를 가리키는 주소값이 있으며 각각의 클래스 인스턴스 주소값을 담을 공간 n개를 담을 공간 5개를 생성하는 문장
       * - 예) Book[] libray = new Book[5];  // Book주소값을 담을 5개 공간이 만들어지고 각 공간은 비어있다. null초기화;
       *
       *
       
 10번. 상속
	/*
	 * [면접]
	 * 상속 : 자식클래스 extends 부모클래스{...}
	 * - extends : 확장하다의 의미
	 * - 공통으로 사용하는 멤버변수와 멤버메서드를 부모클래스에서 정의한다.
	 * - 부모클래스는 일반적이고 공통적이며, 자식클래스는 구체적이고 유일하다.
	 * 
	 * - 사용이유 : 부모클래스의 멤버변수와 멤버메서드를 재사용.
	 * 			중복되는 코드를 줄임으로써 손쉽게 개발, 유지보수 가능
	 * - 부모클래스의 멤버를 private으로 선언한경우, 자식클래스에서 접근할 수 없다.
	 * 	 접근제어자 protected의 경우 자식클래스에서 접근가능			
	 */
	 /*244page
		 * super : 부모의 참조변수
		 * - 하위클래스에서 상위클래스로 접근할 때 사용한다.
		 * 하위클래스는 상위클래스의 주소, 즉 참조값을 알고 있다.
		 * 예)super.printInfo();
		 * -상위클래스의 생성자를 호출할 때도 사용한다.
		 * 예)super();
		 * cf)this : 자기자신의 주소값
		 */
		 
 11. call by reference // 메서드 호출시 매개변수에 주소전달 (메서드 호출시 호출 대상 부모매개변수에 주소값 전달_ch06_08Main참조)
 	 call by value // 메서드 호출시 매개변수에 값전달 (디폴트생성자 - setter, 매개변수생성자) 		 		 
 
 12번. 추상메서드
	/*
       * 추상이란?
       * - 여러가지 사물이나 개념으로부터 공통이 되는 특성을 파악하는 것을 말한다.
       * 
       * [면접]
       * 1. 추상클래스 => 작업명세서
       * - 하나 이상의 추상메서드를 가지고 있는 클래스를 의미한다.
       * - abstract 키워드를 이용하여 구현되지 않는 추상메서드를 기술할 수 있다.
       * - 자식클래스에게 구현을 위임하고자 할 때 사용되며, 프로그램의 확장성을 위해 많이 사용하는 설계방법이다.
       * - 추상클래스는 일반메서드, 추상메서드 모두 올 수 있다.
       * - 전제조건은 반드시 상속을 해야 한다.
       * - 다형성 적용 가능하다.
       * 
       * - 문법 : public abstract class 클래스명 {
       *             public abstract 반환형 메서드명();  // 추상메서드
       *       }
       * 
       * 2. 추상메서드
       * - 하위클래스가 어떤 클래스냐에 따라 구현코드가 달라지며, 하위클래스에 구현을 위임하는 것이다.
       * - 미완성되어있는 메서드이며, 몸체가 없는 메서드로서 항상 세미콜론(;)으로 종료되어야 한다.
       * 
       *  3. 추상클래스의 상속
       *  - 추상클래스를 상속받은 자식클래스는 추상메서드를 반드시 재정의(Override) 해야 하며,
       *    재정의하지 않으면 컴파일 오류가 발생한다.
       *  - 자식클래스에게 강제성과 통일성을 줄 수 있다.(협업시 작업명세서)  
       *       
       * 4. 추상클래스의 객체 생성
       * - 추상클래스는 객체를 생성할 수 없으며(추상 메서드 때문), 상속 계층에서
       *   추상적인 개념을 나타내기 위한 용도로 사용한다.
       * - 상속을 통하여 자식클래스에서 추상메서드를 구현하고, 자식클래스 객체를 생성하여 메서드를 접근할 수 있다.  
       * 
       */
 13번. 인터페이스
 /*
		    * [면접] 추상클래스 vs 인터페이스
		    *       인터페이스 설명
		    *       
		    *  인터페이스 
		    *  - 기능정의서(표준 작업명세서)이다. - 강제성과 통일성
		    *  - 설계(선언)와 구현을 분리시키는 것을 가능하게 한다.
		    *    (설계 : 인터페이스, 구현 : 자식클래스)
		    *  - 객체생성 불가능하며, 객체 Type으로 가능하다.(다형성 적용)
		    *  - 인터페이스의 멤버는 상수(static final 생략 가능), 추상메서드(abstract 생략 가능)만 올수 있다.
		    *  - 단 static 메서드, 디폴트 메서드, private 메서드는 예외(JDK 1.8부터)
		    *  - 인터페이스를 implements(=구현)할 자식클래스에서 추상메서드를 재정의한다.
		    *  
		    *  1. 인터페이스 작성
		    *  interface 인터페이스명 {
		    *     // 상수
		    *     public static final 데이터타입 대문자상수명 = 값;
		    *      // 추상메서드
		    *      public 반환형 추상메서드(매개변수1,...);  // body없다
		    *  }
		    *  
		    *  2. 인터페이스 구현
		    *  class 클래스명 implements 인터페이스명{
		    *     @Override
		    *      public 반환형 추상메서드(매개변수1,...) {
		    *          // 인터페이스에 정의된 추상메서드를 구현해야 한다.
		    *       }
		    *  }
		    * 
		    * 3. 인터페이스는 다중 상속 가능    cf) 클래스는 단일 상속만 가능
		    * interface 인터페이스명  extends  인터페이스명1, .. 인터페이스명n {
		    * 
		    * }
		    * 
		    * class 클래스명  extends  클래스명1, .. 클래스명n {  //NG - 클래스는 단일 상속만 가능
		    * }
		    * 
		    * 4. 상속과 구현을 동시
		    * class 클래스명 extends 부모클래스 implements 인터페이스명1, .. 인터페이스명n {
		    * 
		    * }
		    *  자바 8부터 디폴트 메서드, 정적메서드를 구현할 수 있다.
		    *  자바 9부터 private 메서드를 구현 할 수 있다.
		    * 
		    */
		  
14. ArrayList
/*
       * 컬렉션 프레임워크
       * 
       * Collection 인터페이스
       * - List 인터페이스 : 클래스 종류는 ArrayList, Vector, LinkedList
       * - Set 인터페이스 : 클래스종류는 HashSet, TreeSet
       * - Map 인터페이스 : 클래스종류는 HashMap, HashTable, TreeMap
       * 
       *  <면접>
       *  1. 특징
       *  List 인터페이스 : 순서가 있는 자료관리, 중복허용한다.
       *                 index를 사용하여 요소에 접근한다.
       *                 리스트에 들어있는 요소들의 인덱스는 0부터 시작한다.
       *                 클래스종류는 ArrayList, Vector, LinkedList
       *                 
       *  Set 인터페이스 : 순서가 없는 자료관리, 중복허용 않는다.
       *                클래스종류는 HashSet, TreeSet
       *                
       * [ArrayList]
       * 2. 선언           
       * ArrayList<데이터타입클래스> 참조변수 = new ArrayList<데이터타입클래스>();
       * 
       * 다형성 적용
       * List<데이터타입클래스> 참조변수 = new ArrayList<데이터타입클래스>();
       *
       * 3. 특징 : 데이터 순서가 있고, 중복허용된다.
       * 4. 추가 : list.add(값);   // 앞에서부터 순서대로 추가
       *         list.add(추가할 위치 index, 값);  // 지정한 인덱스에 값을 추가, 그 뒤값은 밀려난다.
       *         
       * 5. 값 가져오기 : list.get(가져올 index);  // list.size() 만큼 반복    
       * 6. 교체 : list.set(교체할 위치 index, 값);  // 지정한 인덱스의 값을 변경.. 그 뒤값은 그대로이다.
       * 7. 삭제 : list.remove(삭제할 위치 index);
       * 8. 검색 : list.indexOf(검색할 값);  // 중요
       *          리스트에서 검색할 값과 똑같은 값을 갇는 첫번째 데이터를 찾아서 그 위치의 인덱스를 리턴한다.
       *          검색할 값과 일치한 데이터가 없으면 -1을 리턴한다.
       * 9. 전체 삭제 : list.clear();
       * 10. 반복자 : Iterator<E> iterator : while(hasNext()) { next() }          
       */

15. HashMap
/*
	 * [면접] 439page
	 * 해싱(hasing) : 키를 이용해서 해시테이블로부터 데이터를 가져오는 과정
	 * 
	 * 
	 * HashMap
	 * 1) 특징
	 * 	- 데이터의 순서를 보장하지 않는다.
	 *  - key와 value 쌍으로 저장한다.
	 *  - key는 중복되면 않된다.
	 *  - key를 이용해서 value를 가져 올 수 있다.
	 *  - List 계열과 달린 index가 없다.
	 *  - Map라는 인터페이스를 구현한 클래스이다.
	 *  
	 *  2) 선언
	 *  - HashMapkey<key 타입, value타입> map = new HashMap <key 타입, value타입>;
	 *  - Map<key 타입, value타입> map = new HashMap <key 타입, value타입>();// 다형성 적용
	 *  
	 *  3) 메서드
	 *  - 데이트 추가 : put(key, value);
	 *  - 데이터 가져오기 : get(key);
	 *  - 데이터 삭제 : remove(key);
	 *  - 데이터가 비어있는지 여부: isEmpay();
	 *  - 해당키가 있는지 여부 : containsKey(key);
	 *  - 해당 값이 있는지 여부 : containsValue(key);
	 *  - 해당 갯수 : size()
	 *  
	 */
	 
15. 예외처리
		/*
		 * 487page
		 * [면접]
		 * 예외처리 목적 : 정상종료 
		 * 
		 * try{
		 *  	// 예외가 발생할 수 있는 부분  
		 * } catch{(처리할 예이타입e){
		 *   // try 블록안에서 예외가 발생했을때 예외를 처리하는 부분
		 * } finally{
		 * 	   //항상 수행되는 부분(예외가 발생하지 않어라도),주로 자원해제를 위한close() 문장이온다.
		 * }
		 */
		 
16. 제네릭 
/*
		 * [면접] - 왜사용하는지 ? 장점이 뭔지 
		 * 제네릭 : 여러 참조자료형이 쓰일 수 있는 곳에 특정한 자료형을 지정하지 않고 
		 * 		제네릭 클래스의 인스턴스 생성시점에 어떤 자료형을 사요할 것인지 지정하는 방식
		 * 		T자료형이 결정되는 시점보다 static이 빠르므로 static에서는 사용할 수 없다.
		 *
		 * 		T : Type parameter
		 * 		E : element
		 * 		K : Key
		 * 		V : Value
		 * 
		 * - 제네릭으로 구현하면 형변환을 하지 않아도 된다.(매개변수의 다형성, 다운캐스팅을 않해도 된다.)
		 * => 제네릭 클래스를 사용하면 컴파일러는 일단 대입된 자료형이 잘 쓰였는지확인한다.
		 * class 파일을 생성할 때 T를 사용한 곳에 지정된 자료형에 따라 컴파일 하므로
		 * 단 제네릭 클래스가 static이면 예외 401page
		 */

17. Thread 

		/* [면접]
		 * Thread 문법
		 * 1) Thread 클래스를상속하기 
		 * 
		 * 1. Thread 클래스를 상속 받아서 클래스를 작성한다.
		 * 2. run() 메서드를 재정의(Override) 한다.
		 * 3. main() 메서드에서 Thread 객체를 생성한다.
		 * 4. start() 메서드를 호출해서 스레드를 실행한다.	 ( 호출은 start)로한다.
		 * 5. run() 메서드가 실행된다.
		 */
		 /*
		 * [면접]
		 * 2) Runnable 인터페이스를 구현하는 방법
		 * 
		 * 1. Runnable 인터페이스를 implements 받아서 클래스를 작성한다.
		 * 2. run() 메서드를 재정의(Override) 한다.
		 * 3. main() 메서드에서 Thread 객체를 생성한다, 이때 implements 받은 클래스 객체를 매개변수로 전달한다.
		 * 4. start() 메서드를 호출해서 스레드를 실행한다.	 ( 호출은 start)로한다.
		 * 5. run() 메서드가 실행된다.
		 */
		 
		 * [synchronized] => 동기화..
		 * 예) A,B,C 세사람이 문서출력.. 출력순서는 달라질수 있으나(시분할), 문서는 섞이면 않된다.
		 * 
		 * 동기화란 공유된 자원중에서 동시에 사용하면 않되는 자원에 대해서 장금장치(Lock)을 수행하여 보호하는 도구이다.
		 * 즉 메서드를 호출할때 객체에 잠금을 하고, 메서드 수행이 끝나면 잠금을 해제한다.
		 * 
		 * 이때 Vector라는 자료구조가 사용되고, 메서드가 호출될때마다 잠금과 해제가 일어나므로 ArrayList보다 수행 속도가 느리다.
		 * 
		 * <임계영역(critical section)의 동기화>
		 * - 한사용자가 자원을 사용하고 있으면, 다른 사용자는 사용이 끝날대 까지 기다려야한다.
		 *   이러한 영역을 임계 영역이라고 한다.
		 *   
		 *   - 한 사용자가 자원을 사용하고 있으면, 다른 사용자는 사용이 끝날때까지 기다려야 한다.
		 *   이러한 영역을 임계영역이라고 한다.
		 
18. 스트림 [ch13._03_] 478page
